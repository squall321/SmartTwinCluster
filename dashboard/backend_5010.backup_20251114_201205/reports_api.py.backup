"""
Reports API
ìë™í™”ëœ ë¦¬í¬íŠ¸ ìƒì„± ë° ë¶„ì„
"""

from flask import Blueprint, request, jsonify, send_file
import pandas as pd
from datetime import datetime, timedelta
import json
import io
import os

# Report exporter import
try:
    from report_exporter import report_exporter
    EXPORTER_AVAILABLE = True
except ImportError:
    EXPORTER_AVAILABLE = False
    print("âš ï¸  report_exporter not available - PDF/Excel export disabled")

# Slurm data collector import
try:
    from slurm_data_collector import (
        get_slurm_jobs_data,
        get_slurm_usage_by_user,
        get_current_cluster_state,
        get_daily_usage_data
    )
    SLURM_COLLECTOR_AVAILABLE = True
except ImportError:
    SLURM_COLLECTOR_AVAILABLE = False
    print("âš ï¸  slurm_data_collector not available - will use mock data")

# Create Blueprint
reports_bp = Blueprint('reports', __name__, url_prefix='/api/reports')

MOCK_MODE = os.getenv('MOCK_MODE', 'true').lower() == 'true'

# ============================================
# Helper Functions
# ============================================

def get_date_range(period: str):
    """ê¸°ê°„ì— ë”°ë¥¸ ë‚ ì§œ ë²”ìœ„ ë°˜í™˜"""
    end_date = datetime.now()
    
    if period == 'today':
        start_date = end_date.replace(hour=0, minute=0, second=0, microsecond=0)
    elif period == 'yesterday':
        start_date = (end_date - timedelta(days=1)).replace(hour=0, minute=0, second=0, microsecond=0)
        end_date = start_date + timedelta(days=1)
    elif period == 'week':
        start_date = end_date - timedelta(days=7)
    elif period == 'month':
        start_date = end_date - timedelta(days=30)
    elif period == 'year':
        start_date = end_date - timedelta(days=365)
    else:
        start_date = end_date - timedelta(days=7)
    
    return start_date, end_date

def generate_mock_usage_data(start_date, end_date):
    """Mock ì‚¬ìš©ëŸ‰ ë°ì´í„° ìƒì„±"""
    import random
    
    days = (end_date - start_date).days
    data = []
    
    for i in range(days):
        date = start_date + timedelta(days=i)
        data.append({
            'date': date.strftime('%Y-%m-%d'),
            'cpu_hours': round(random.uniform(100, 500), 2),
            'gpu_hours': round(random.uniform(50, 200), 2),
            'memory_gb_hours': round(random.uniform(500, 2000), 2),
            'jobs_submitted': random.randint(10, 50),
            'jobs_completed': random.randint(8, 45),
            'jobs_failed': random.randint(0, 5)
        })
    
    return data

def generate_mock_user_data():
    """Mock ì‚¬ìš©ì ë°ì´í„° ìƒì„±"""
    import random
    
    users = []
    user_names = ['user1', 'user2', 'user3', 'user4', 'user5']
    
    for name in user_names:
        users.append({
            'username': name,
            'cpu_hours': round(random.uniform(50, 200), 2),
            'gpu_hours': round(random.uniform(20, 100), 2),
            'memory_gb_hours': round(random.uniform(200, 800), 2),
            'jobs_total': random.randint(20, 100),
            'jobs_success': random.randint(18, 95),
            'jobs_failed': random.randint(0, 5),
            'cost': round(random.uniform(100, 1000), 2)
        })
    
    return users

def calculate_costs(cpu_hours, gpu_hours, memory_gb_hours):
    """ë¹„ìš© ê³„ì‚°"""
    CPU_COST_PER_HOUR = 0.5
    GPU_COST_PER_HOUR = 2.0
    MEMORY_COST_PER_GB_HOUR = 0.01
    
    cpu_cost = cpu_hours * CPU_COST_PER_HOUR
    gpu_cost = gpu_hours * GPU_COST_PER_HOUR
    memory_cost = memory_gb_hours * MEMORY_COST_PER_GB_HOUR
    
    return {
        'cpu_cost': round(cpu_cost, 2),
        'gpu_cost': round(gpu_cost, 2),
        'memory_cost': round(memory_cost, 2),
        'total_cost': round(cpu_cost + gpu_cost + memory_cost, 2)
    }

# ============================================
# GET /api/reports/usage
# ì‚¬ìš©ëŸ‰ ë¦¬í¬íŠ¸
# ============================================
@reports_bp.route('/usage', methods=['GET'])
def usage_report():
    """
    ë¦¬ì†ŒìŠ¤ ì‚¬ìš©ëŸ‰ ë¦¬í¬íŠ¸
    Query params:
        - period: today, yesterday, week, month, year
        - start_date: YYYY-MM-DD (optional)
        - end_date: YYYY-MM-DD (optional)
    """
    period = request.args.get('period', 'week')
    start_str = request.args.get('start_date')
    end_str = request.args.get('end_date')
    
    # ë‚ ì§œ ë²”ìœ„ ì„¤ì •
    if start_str and end_str:
        start_date = datetime.strptime(start_str, '%Y-%m-%d')
        end_date = datetime.strptime(end_str, '%Y-%m-%d')
    else:
        start_date, end_date = get_date_range(period)
    
    # Production ëª¨ë“œ: ì‹¤ì œ Slurm ë°ì´í„° ìˆ˜ì§‘
    if not MOCK_MODE and SLURM_COLLECTOR_AVAILABLE:
        print(f"ğŸ“Š [PRODUCTION] Usage report: {start_date.date()} to {end_date.date()}")
        
        try:
            # Slurmì—ì„œ ì‹¤ì œ ë°ì´í„° ìˆ˜ì§‘
            daily_data = get_daily_usage_data(start_date, end_date)
            jobs_data = get_slurm_jobs_data(start_date, end_date)
            
            # ì´ê³„ ê³„ì‚°
            total = {
                'cpu_hours': sum(d['cpu_hours'] for d in daily_data),
                'gpu_hours': sum(d['gpu_hours'] for d in daily_data),
                'memory_gb_hours': sum(d['memory_gb_hours'] for d in daily_data),
                'jobs_submitted': jobs_data['total'],
                'jobs_completed': jobs_data['completed'],
                'jobs_failed': jobs_data['failed']
            }
            
            # ë¹„ìš© ê³„ì‚°
            costs = calculate_costs(
                total['cpu_hours'],
                total['gpu_hours'],
                total['memory_gb_hours']
            )
            
            return jsonify({
                'status': 'success',
                'mode': 'production',
                'period': {
                    'start': start_date.strftime('%Y-%m-%d'),
                    'end': end_date.strftime('%Y-%m-%d'),
                    'days': (end_date - start_date).days
                },
                'daily_data': daily_data,
                'total': total,
                'costs': costs,
                'generated_at': datetime.now().isoformat()
            })
        except Exception as e:
            print(f"âŒ Error collecting Slurm data: {e}")
            import traceback
            traceback.print_exc()
            # ì—ëŸ¬ ì‹œ Mock ë°ì´í„°ë¡œ fallback
            print("âš ï¸  Falling back to mock data")
    
    # Mock ëª¨ë“œ ë˜ëŠ” Fallback
    mode_label = "[MOCK]" if MOCK_MODE else "[DEMO-FALLBACK]"
    print(f"ğŸ“Š {mode_label} Usage report: {start_date.date()} to {end_date.date()}")
    
    data = generate_mock_usage_data(start_date, end_date)
    
    # ì´ê³„ ê³„ì‚°
    total = {
        'cpu_hours': sum(d['cpu_hours'] for d in data),
        'gpu_hours': sum(d['gpu_hours'] for d in data),
        'memory_gb_hours': sum(d['memory_gb_hours'] for d in data),
        'jobs_submitted': sum(d['jobs_submitted'] for d in data),
        'jobs_completed': sum(d['jobs_completed'] for d in data),
        'jobs_failed': sum(d['jobs_failed'] for d in data)
    }
    
    # ë¹„ìš© ê³„ì‚°
    costs = calculate_costs(
        total['cpu_hours'],
        total['gpu_hours'],
        total['memory_gb_hours']
    )
    
    return jsonify({
        'status': 'success',
        'mode': 'mock' if MOCK_MODE else 'demo',
        'period': {
            'start': start_date.strftime('%Y-%m-%d'),
            'end': end_date.strftime('%Y-%m-%d'),
            'days': (end_date - start_date).days
        },
        'daily_data': data,
        'total': total,
        'costs': costs,
        'generated_at': datetime.now().isoformat()
    })

# ============================================
# GET /api/reports/download/{type}/{format}
# ë¦¬í¬íŠ¸ ë‹¤ìš´ë¡œë“œ (ê°„ë‹¨í•œ ë°©ë²•)
# ============================================
@reports_bp.route('/download/<report_type>/<format_type>', methods=['GET'])
def download_report(report_type, format_type):
    """
    ë¦¬í¬íŠ¸ ë‹¤ìš´ë¡œë“œ
    URL params:
        - report_type: usage, costs
        - format_type: pdf, excel
    Query params:
        - period: week, month, year (default: week)
    """
    period = request.args.get('period', 'week')
    
    if MOCK_MODE:
        print(f"ğŸ’¾ [MOCK] Download {report_type} report as {format_type} (period: {period})")
        
        if not EXPORTER_AVAILABLE:
            return jsonify({
                'status': 'error',
                'message': 'Report exporter not available'
            }), 500
        
        try:
            # ë¦¬í¬íŠ¸ ë°ì´í„° ìˆ˜ì§‘
            if report_type == 'usage':
                # period íŒŒë¼ë¯¸í„°ë¥¼ ì „ë‹¬í•˜ê¸° ìœ„í•´ request.args ì„¤ì •
                with request.application.test_request_context(f'?period={period}'):
                    report_data = usage_report().get_json()
            elif report_type == 'costs':
                with request.application.test_request_context(f'?period={period}'):
                    report_data = costs_report().get_json()
            else:
                return jsonify({
                    'status': 'error',
                    'message': f'Unknown report type: {report_type}'
                }), 400
            
            # PDF ìƒì„±
            if format_type == 'pdf':
                if report_type == 'usage':
                    buffer = report_exporter.generate_usage_report_pdf(report_data)
                elif report_type == 'costs':
                    buffer = report_exporter.generate_costs_report_pdf(report_data)
                else:
                    return jsonify({'status': 'error', 'message': 'Invalid report type'}), 400
                
                filename = f"{report_type}_report_{period}_{datetime.now().strftime('%Y%m%d')}.pdf"
                return send_file(
                    buffer,
                    mimetype='application/pdf',
                    as_attachment=True,
                    download_name=filename
                )
            
            # Excel ìƒì„±
            elif format_type == 'excel':
                if report_type == 'usage':
                    buffer = report_exporter.generate_usage_report_excel(report_data)
                elif report_type == 'costs':
                    buffer = report_exporter.generate_costs_report_excel(report_data)
                else:
                    return jsonify({'status': 'error', 'message': 'Invalid report type'}), 400
                
                filename = f"{report_type}_report_{period}_{datetime.now().strftime('%Y%m%d')}.xlsx"
                return send_file(
                    buffer,
                    mimetype='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
                    as_attachment=True,
                    download_name=filename
                )
            else:
                return jsonify({
                    'status': 'error',
                    'message': f'Invalid format: {format_type}'
                }), 400
            
        except Exception as e:
            print(f"âŒ Error generating report: {e}")
            import traceback
            traceback.print_exc()
            return jsonify({
                'status': 'error',
                'message': f'Failed to generate report: {str(e)}'
            }), 500
    
    return jsonify({'error': 'Not implemented in production mode'}), 501

# ============================================
# GET /api/reports/jobs
# ì‘ì—… ë¦¬í¬íŠ¸
# ============================================
@reports_bp.route('/jobs', methods=['GET'])
def jobs_report():
    """
    ì‘ì—… í†µê³„ ë¦¬í¬íŠ¸
    Query params:
        - period: today, yesterday, week, month, year
    """
    period = request.args.get('period', 'week')
    start_date, end_date = get_date_range(period)
    
    mode_label = "[MOCK]" if MOCK_MODE else "[DEMO]"
    print(f"ğŸ“Š {mode_label} Jobs report: {start_date.date()} to {end_date.date()}")
    
    import random
    
    total_jobs = random.randint(100, 500)
    completed = random.randint(80, int(total_jobs * 0.95))
    failed = random.randint(5, int(total_jobs * 0.1))
    running = random.randint(0, 10)
    pending = total_jobs - completed - failed - running
    
    return jsonify({
        'status': 'success',
        'period': {
            'start': start_date.strftime('%Y-%m-%d'),
            'end': end_date.strftime('%Y-%m-%d')
        },
        'summary': {
            'total': total_jobs,
            'completed': completed,
            'failed': failed,
            'running': running,
            'pending': pending,
            'success_rate': round((completed / total_jobs) * 100, 2)
        },
        'by_state': {
            'COMPLETED': completed,
            'FAILED': failed,
            'RUNNING': running,
            'PENDING': pending
        },
        'average_wait_time': round(random.uniform(5, 60), 2),
        'average_run_time': round(random.uniform(30, 300), 2),
        'generated_at': datetime.now().isoformat()
    })

# ============================================
# GET /api/reports/users
# ì‚¬ìš©ìë³„ ë¦¬í¬íŠ¸
# ============================================
@reports_bp.route('/users', methods=['GET'])
def users_report():
    """
    ì‚¬ìš©ìë³„ ì‚¬ìš©ëŸ‰ ë¦¬í¬íŠ¸
    Query params:
        - period: week, month, year
        - limit: ìƒìœ„ Nëª… (default: 10)
    """
    period = request.args.get('period', 'month')
    limit = int(request.args.get('limit', 10))
    start_date, end_date = get_date_range(period)
    
    mode_label = "[MOCK]" if MOCK_MODE else "[DEMO]"
    print(f"ğŸ“Š {mode_label} Users report: {start_date.date()} to {end_date.date()}")
    
    users = generate_mock_user_data()
    
    # CPU ì‚¬ìš©ëŸ‰ ê¸°ì¤€ ì •ë ¬
    users_sorted = sorted(users, key=lambda x: x['cpu_hours'], reverse=True)[:limit]
    
    # ì´ê³„
    total = {
        'users': len(users),
        'cpu_hours': sum(u['cpu_hours'] for u in users),
        'gpu_hours': sum(u['gpu_hours'] for u in users),
        'total_cost': sum(u['cost'] for u in users)
    }
    
    return jsonify({
        'status': 'success',
        'period': {
            'start': start_date.strftime('%Y-%m-%d'),
            'end': end_date.strftime('%Y-%m-%d')
        },
        'top_users': users_sorted,
        'total': total,
        'generated_at': datetime.now().isoformat()
    })

# ============================================
# GET /api/reports/costs
# ë¹„ìš© ë¦¬í¬íŠ¸
# ============================================
@reports_bp.route('/costs', methods=['GET'])
def costs_report():
    """
    ë¹„ìš© ë¶„ì„ ë¦¬í¬íŠ¸
    Query params:
        - period: week, month, year
    """
    period = request.args.get('period', 'month')
    start_date, end_date = get_date_range(period)
    
    mode_label = "[MOCK]" if MOCK_MODE else "[DEMO]"
    print(f"ğŸ“Š {mode_label} Costs report: {start_date.date()} to {end_date.date()}")
    
    import random
    
    # ì¼ë³„ ë¹„ìš© ë°ì´í„°
    days = (end_date - start_date).days
    daily_costs = []
    
    for i in range(days):
        date = start_date + timedelta(days=i)
        cpu_hours = round(random.uniform(100, 500), 2)
        gpu_hours = round(random.uniform(50, 200), 2)
        memory_gb_hours = round(random.uniform(500, 2000), 2)
        
        costs = calculate_costs(cpu_hours, gpu_hours, memory_gb_hours)
        
        daily_costs.append({
            'date': date.strftime('%Y-%m-%d'),
            **costs
        })
    
    # ì´ ë¹„ìš©
    total_cost = sum(d['total_cost'] for d in daily_costs)
    cpu_cost = sum(d['cpu_cost'] for d in daily_costs)
    gpu_cost = sum(d['gpu_cost'] for d in daily_costs)
    memory_cost = sum(d['memory_cost'] for d in daily_costs)
    
    return jsonify({
        'status': 'success',
        'period': {
            'start': start_date.strftime('%Y-%m-%d'),
            'end': end_date.strftime('%Y-%m-%d')
        },
        'daily_costs': daily_costs,
        'total': {
            'cpu_cost': round(cpu_cost, 2),
            'gpu_cost': round(gpu_cost, 2),
            'memory_cost': round(memory_cost, 2),
            'total_cost': round(total_cost, 2)
        },
        'breakdown': {
            'cpu_percentage': round((cpu_cost / total_cost) * 100, 2),
            'gpu_percentage': round((gpu_cost / total_cost) * 100, 2),
            'memory_percentage': round((memory_cost / total_cost) * 100, 2)
        },
        'rates': {
            'cpu_per_hour': 0.5,
            'gpu_per_hour': 2.0,
            'memory_per_gb_hour': 0.01
        },
        'generated_at': datetime.now().isoformat()
    })

# ============================================
# GET /api/reports/efficiency
# íš¨ìœ¨ì„± ë¦¬í¬íŠ¸
# ============================================
@reports_bp.route('/efficiency', methods=['GET'])
def efficiency_report():
    """
    ë¦¬ì†ŒìŠ¤ í™œìš© íš¨ìœ¨ì„± ë¦¬í¬íŠ¸
    Query params:
        - period: week, month
    """
    period = request.args.get('period', 'week')
    start_date, end_date = get_date_range(period)
    
    if MOCK_MODE:
        print(f"ğŸ“Š [MOCK] Efficiency report: {start_date.date()} to {end_date.date()}")
        
        import random
        
        return jsonify({
            'status': 'success',
            'period': {
                'start': start_date.strftime('%Y-%m-%d'),
                'end': end_date.strftime('%Y-%m-%d')
            },
            'utilization': {
                'cpu': round(random.uniform(60, 90), 2),
                'gpu': round(random.uniform(70, 95), 2),
                'memory': round(random.uniform(65, 85), 2),
                'storage': round(random.uniform(50, 80), 2)
            },
            'efficiency_score': round(random.uniform(70, 90), 2),
            'idle_time': {
                'cpu_hours': round(random.uniform(50, 200), 2),
                'gpu_hours': round(random.uniform(20, 100), 2)
            },
            'recommendations': [
                'GPU í™œìš©ë¥ ì´ ë†’ìŠµë‹ˆë‹¤. ì¶”ê°€ GPU ê³ ë ¤í•˜ì„¸ìš”.',
                'CPU idle ì‹œê°„ì´ ë§ìŠµë‹ˆë‹¤. ì‘ì—… ìŠ¤ì¼€ì¤„ë§ì„ ìµœì í™”í•˜ì„¸ìš”.',
                'ë©”ëª¨ë¦¬ ì‚¬ìš©ì´ íš¨ìœ¨ì ì…ë‹ˆë‹¤.'
            ],
            'generated_at': datetime.now().isoformat()
        })
    
    return jsonify({'error': 'Not implemented in production mode'}), 501

# ============================================
# GET /api/reports/overview
# ì¢…í•© ê°œìš”
# ============================================
@reports_bp.route('/overview', methods=['GET'])
def overview_report():
    """
    ì „ì²´ ì‹œìŠ¤í…œ ê°œìš”
    """
    if MOCK_MODE:
        print("ğŸ“Š [MOCK] Overview report")
        
        import random
        
        return jsonify({
            'status': 'success',
            'summary': {
                'total_users': random.randint(10, 50),
                'active_users': random.randint(5, 30),
                'total_jobs_today': random.randint(20, 100),
                'running_jobs': random.randint(5, 20),
                'pending_jobs': random.randint(0, 10)
            },
            'resources': {
                'cpu_utilization': round(random.uniform(60, 90), 2),
                'gpu_utilization': round(random.uniform(70, 95), 2),
                'memory_utilization': round(random.uniform(65, 85), 2)
            },
            'costs_today': round(random.uniform(100, 500), 2),
            'costs_this_month': round(random.uniform(3000, 10000), 2),
            'generated_at': datetime.now().isoformat()
        })
    
    return jsonify({'error': 'Not implemented in production mode'}), 501

# ============================================
# POST /api/reports/generate
# ë¦¬í¬íŠ¸ ìƒì„± (PDF/Excel)
# ============================================
@reports_bp.route('/generate', methods=['POST'])
def generate_report():
    """
    ë¦¬í¬íŠ¸ ìƒì„±
    Body:
        - type: usage, jobs, users, costs, efficiency
        - format: pdf, excel, json
        - period: week, month, year
    """
    data = request.json
    report_type = data.get('type', 'usage')
    format_type = data.get('format', 'json')
    period = data.get('period', 'week')
    
    if MOCK_MODE:
        print(f"ğŸ“Š [MOCK] Generate {report_type} report as {format_type}")
        
        # JSON í˜•ì‹ì€ ë°”ë¡œ ë°˜í™˜
        if format_type == 'json':
            if report_type == 'usage':
                return usage_report()
            elif report_type == 'jobs':
                return jobs_report()
            elif report_type == 'users':
                return users_report()
            elif report_type == 'costs':
                return costs_report()
            elif report_type == 'efficiency':
                return efficiency_report()
        
        # PDF/Excel ìƒì„±
        if not EXPORTER_AVAILABLE:
            return jsonify({
                'status': 'error',
                'message': 'Report exporter not available. Install required packages.'
            }), 500
        
        try:
            # ë¦¬í¬íŠ¸ ë°ì´í„° ìˆ˜ì§‘
            if report_type == 'usage':
                report_data = usage_report().get_json()
            elif report_type == 'costs':
                report_data = costs_report().get_json()
            else:
                return jsonify({
                    'status': 'error',
                    'message': f'PDF/Excel export not supported for {report_type} yet'
                }), 400
            
            # PDF ìƒì„±
            if format_type == 'pdf':
                if report_type == 'usage':
                    buffer = report_exporter.generate_usage_report_pdf(report_data)
                elif report_type == 'costs':
                    buffer = report_exporter.generate_costs_report_pdf(report_data)
                
                filename = f"{report_type}_report_{period}_{datetime.now().strftime('%Y%m%d')}.pdf"
                return send_file(
                    buffer,
                    mimetype='application/pdf',
                    as_attachment=True,
                    download_name=filename
                )
            
            # Excel ìƒì„±
            elif format_type == 'excel':
                if report_type == 'usage':
                    buffer = report_exporter.generate_usage_report_excel(report_data)
                elif report_type == 'costs':
                    buffer = report_exporter.generate_costs_report_excel(report_data)
                
                filename = f"{report_type}_report_{period}_{datetime.now().strftime('%Y%m%d')}.xlsx"
                return send_file(
                    buffer,
                    mimetype='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
                    as_attachment=True,
                    download_name=filename
                )
            
        except Exception as e:
            print(f"âŒ Error generating {format_type}: {e}")
            import traceback
            traceback.print_exc()
            return jsonify({
                'status': 'error',
                'message': f'Failed to generate {format_type}: {str(e)}'
            }), 500
    
    return jsonify({'error': 'Not implemented in production mode'}), 501

# ============================================
# GET /api/reports/stats/trends
# ì¶”ì„¸ ë¶„ì„
# ============================================
@reports_bp.route('/stats/trends', methods=['GET'])
def trends_analysis():
    """
    ë¦¬ì†ŒìŠ¤ ì‚¬ìš© ì¶”ì„¸ ë¶„ì„
    Query params:
        - resource: cpu, gpu, memory, jobs
        - period: month, year
    """
    resource = request.args.get('resource', 'cpu')
    period = request.args.get('period', 'month')
    
    start_date, end_date = get_date_range(period)
    
    if MOCK_MODE:
        print(f"ğŸ“Š [MOCK] Trends analysis: {resource} for {period}")
        
        import random
        
        # ì¼ë³„ ë°ì´í„° ìƒì„±
        days = (end_date - start_date).days
        trend_data = []
        
        base_value = 100
        for i in range(days):
            date = start_date + timedelta(days=i)
            # ì•½ê°„ì˜ ìƒìŠ¹ ì¶”ì„¸ + ëœë¤ ë³€ë™
            value = base_value + (i * 0.5) + random.uniform(-10, 10)
            trend_data.append({
                'date': date.strftime('%Y-%m-%d'),
                'value': round(value, 2)
            })
        
        return jsonify({
            'status': 'success',
            'resource': resource,
            'period': {
                'start': start_date.strftime('%Y-%m-%d'),
                'end': end_date.strftime('%Y-%m-%d')
            },
            'data': trend_data,
            'analysis': {
                'trend': 'increasing',
                'average': round(sum(d['value'] for d in trend_data) / len(trend_data), 2),
                'peak': max(d['value'] for d in trend_data),
                'low': min(d['value'] for d in trend_data)
            },
            'generated_at': datetime.now().isoformat()
        })
    
    return jsonify({'error': 'Not implemented in production mode'}), 501

print("âœ… Reports API initialized")
