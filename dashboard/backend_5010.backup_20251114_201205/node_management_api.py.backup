"""
ë…¸ë“œ ê´€ë¦¬ API (Flask ë²„ì „)
- Drain/Resume/Reboot ê¸°ëŠ¥
- ë…¸ë“œ ìƒíƒœ ì¡°íšŒ
- ì‘ì—… ì´ë ¥ ê¸°ë¡
"""
from flask import Blueprint, request, jsonify
import subprocess
from datetime import datetime
import logging
import os

# ë¡œê±° ì„¤ì •
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Blueprint ìƒì„± (url_prefix ì¶”ê°€)
node_bp = Blueprint('node_management', __name__, url_prefix='/api')

# Mock ëª¨ë“œ í™•ì¸
MOCK_MODE = os.getenv('MOCK_MODE', 'true').lower() == 'true'

# ë°ì´í„°ë² ì´ìŠ¤ (ê°„ë‹¨í•œ ì¸ë©”ëª¨ë¦¬ ì €ì¥ì†Œ, ì¶”í›„ SQLiteë¡œ í™•ì¥)
node_history = []


def run_slurm_command(command, mock_response=None):
    """
    Slurm ëª…ë ¹ì–´ ì‹¤í–‰ (Mock ëª¨ë“œ ì§€ì›)
    """
    if MOCK_MODE and mock_response is not None:
        logger.info(f"ğŸ­ Mock mode: {' '.join(command)}")
        return True, mock_response, ""
    
    try:
        result = subprocess.run(
            command,
            capture_output=True,
            text=True,
            timeout=10
        )
        return result.returncode == 0, result.stdout, result.stderr
    except subprocess.TimeoutExpired:
        return False, "", "Command timeout"
    except Exception as e:
        return False, "", str(e)


@node_bp.route('/nodes', methods=['GET'])
def get_nodes():
    """
    ëª¨ë“  ë…¸ë“œ ëª©ë¡ ë° ìƒíƒœ ì¡°íšŒ
    GET /api/nodes
    """
    try:
        if MOCK_MODE:
            # Mock ë°ì´í„°
            nodes = [
                {
                    'name': 'cn01',
                    'state': 'IDLE',
                    'cpus': '64/0/0/64',
                    'memory': '256000',
                    'free_memory': '200000',
                    'cpu_load': '0.50',
                    'time_limit': 'infinite',
                    'nodes': '1'
                },
                {
                    'name': 'cn02',
                    'state': 'ALLOCATED',
                    'cpus': '64/48/0/64',
                    'memory': '256000',
                    'free_memory': '100000',
                    'cpu_load': '12.30',
                    'time_limit': 'infinite',
                    'nodes': '1'
                },
                {
                    'name': 'cn03',
                    'state': 'DRAINED',
                    'cpus': '64/0/0/64',
                    'memory': '256000',
                    'free_memory': '250000',
                    'cpu_load': '0.00',
                    'time_limit': 'infinite',
                    'nodes': '1'
                },
                {
                    'name': 'cn04',
                    'state': 'IDLE',
                    'cpus': '64/0/0/64',
                    'memory': '256000',
                    'free_memory': '220000',
                    'cpu_load': '0.10',
                    'time_limit': 'infinite',
                    'nodes': '1'
                }
            ]
            actual_mode = 'mock'
        else:
            # ì‹¤ì œ Slurm ëª…ë ¹ì–´ ì‹¤í–‰
            success, stdout, stderr = run_slurm_command(
                ['sinfo', '-N', '-o', '%N|%T|%C|%m|%e|%O|%l|%D']
            )
            
            if not success:
                # Slurm ëª…ë ¹ì–´ ì‹¤íŒ¨ ì‹œ Mock ë°ì´í„°ë¡œ Fallback
                logger.warning(f"Slurm command failed: {stderr}. Falling back to mock data.")
                nodes = [
                    {'name': 'node01', 'state': 'IDLE', 'cpus': '32/0/0/32', 'memory': '128000', 'free_memory': '120000', 'cpu_load': '0.50', 'time_limit': 'infinite', 'nodes': '1'},
                    {'name': 'node02', 'state': 'ALLOCATED', 'cpus': '32/16/0/32', 'memory': '128000', 'free_memory': '64000', 'cpu_load': '5.20', 'time_limit': 'infinite', 'nodes': '1'}
                ]
                actual_mode = 'mock'  # Slurm ì—†ìœ¼ë¯€ë¡œ mockìœ¼ë¡œ í‘œì‹œ
            else:
                # ê²°ê³¼ íŒŒì‹±
                lines = stdout.strip().split('\n')
                nodes = []
                
                for line in lines[1:]:  # í—¤ë” ìŠ¤í‚µ
                    parts = line.split('|')
                    if len(parts) >= 8:
                        nodes.append({
                            'name': parts[0],
                            'state': parts[1],
                            'cpus': parts[2],
                            'memory': parts[3],
                            'free_memory': parts[4],
                            'cpu_load': parts[5],
                            'time_limit': parts[6],
                            'nodes': parts[7]
                        })
                actual_mode = 'production'
        
        return jsonify({
            'success': True,
            'nodes': nodes,
            'count': len(nodes),
            'mode': actual_mode,
            'timestamp': datetime.now().isoformat()
        })
        
    except Exception as e:
        logger.error(f"Error fetching nodes: {str(e)}")
        # ì˜ˆì™¸ ë°œìƒ ì‹œë„ Mock ë°ì´í„° ë°˜í™˜
        return jsonify({
            'success': True,
            'nodes': [
                {'name': 'fallback-node', 'state': 'UNKNOWN', 'cpus': '0/0/0/0', 'memory': '0', 'free_memory': '0', 'cpu_load': '0.00', 'time_limit': 'infinite', 'nodes': '1'}
            ],
            'count': 1,
            'mode': 'mock',
            'error_message': str(e),
            'timestamp': datetime.now().isoformat()
        })


@node_bp.route('/nodes/<node_name>', methods=['GET'])
def get_node_detail(node_name):
    """
    íŠ¹ì • ë…¸ë“œì˜ ìƒì„¸ ì •ë³´ ì¡°íšŒ
    GET /api/nodes/<node_name>
    """
    try:
        if MOCK_MODE:
            # Mock ë°ì´í„°
            node_info = {
                'NodeName': node_name,
                'State': 'IDLE' if node_name != 'cn03' else 'DRAINED',
                'CPUAlloc': '0' if node_name != 'cn02' else '48',
                'CPUTot': '64',
                'RealMemory': '256000',
                'AllocMem': '0' if node_name != 'cn02' else '128000',
                'FreeMem': '220000',
                'CPULoad': '0.50' if node_name != 'cn02' else '12.30',
                'Partitions': 'standard,gpu',
                'OS': 'Linux 5.15.0',
                'Arch': 'x86_64',
                'Reason': 'Manual maintenance' if node_name == 'cn03' else 'None'
            }
        else:
            # ì‹¤ì œ Slurm ëª…ë ¹ì–´ ì‹¤í–‰
            success, stdout, stderr = run_slurm_command(
                ['scontrol', 'show', 'node', node_name]
            )
            
            if not success:
                return jsonify({
                    'success': False,
                    'error': f'Node {node_name} not found',
                    'details': stderr
                }), 404
            
            # ê²°ê³¼ë¥¼ ë”•ì…”ë„ˆë¦¬ë¡œ ë³€í™˜
            node_info = {}
            for line in stdout.split('\n'):
                if '=' in line:
                    key_value_pairs = line.split()
                    for pair in key_value_pairs:
                        if '=' in pair:
                            key, value = pair.split('=', 1)
                            node_info[key] = value
        
        return jsonify({
            'success': True,
            'node': node_info,
            'mode': 'mock' if MOCK_MODE else 'production',
            'timestamp': datetime.now().isoformat()
        })
        
    except Exception as e:
        logger.error(f"Error fetching node detail: {str(e)}")
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500


@node_bp.route('/nodes/drain', methods=['POST'])
def drain_node():
    """
    ë…¸ë“œë¥¼ DRAIN ìƒíƒœë¡œ ë³€ê²½
    POST /api/nodes/drain
    Body: { "node_name": "cn01", "reason": "maintenance" }
    """
    try:
        data = request.get_json()
        node_name = data.get('node_name')
        reason = data.get('reason', 'Manual maintenance')
        
        if not node_name:
            return jsonify({
                'success': False,
                'error': 'node_name is required'
            }), 400
        
        if MOCK_MODE:
            # Mock ëª¨ë“œì—ì„œëŠ” ì„±ê³µìœ¼ë¡œ ê°„ì£¼
            logger.info(f"ğŸ­ Mock: Draining node {node_name} with reason: {reason}")
            success = True
        else:
            # ì‹¤ì œ Slurm ëª…ë ¹ì–´ ì‹¤í–‰
            success, stdout, stderr = run_slurm_command(
                ['scontrol', 'update', f'NodeName={node_name}', 
                 'State=DRAIN', f'Reason="{reason}"']
            )
            
            if not success:
                return jsonify({
                    'success': False,
                    'error': 'Failed to drain node',
                    'details': stderr
                }), 500
        
        # ì´ë ¥ ê¸°ë¡
        history_entry = {
            'timestamp': datetime.now().isoformat(),
            'action': 'drain',
            'node_name': node_name,
            'reason': reason,
            'success': True
        }
        node_history.append(history_entry)
        
        return jsonify({
            'success': True,
            'message': f'Node {node_name} drained successfully',
            'node_name': node_name,
            'reason': reason,
            'mode': 'mock' if MOCK_MODE else 'production',
            'timestamp': datetime.now().isoformat()
        })
        
    except Exception as e:
        logger.error(f"Error draining node: {str(e)}")
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500


@node_bp.route('/nodes/resume', methods=['POST'])
def resume_node():
    """
    ë…¸ë“œë¥¼ RESUME ìƒíƒœë¡œ ë³€ê²½
    POST /api/nodes/resume
    Body: { "node_name": "cn01" }
    """
    try:
        data = request.get_json()
        node_name = data.get('node_name')
        
        if not node_name:
            return jsonify({
                'success': False,
                'error': 'node_name is required'
            }), 400
        
        if MOCK_MODE:
            # Mock ëª¨ë“œì—ì„œëŠ” ì„±ê³µìœ¼ë¡œ ê°„ì£¼
            logger.info(f"ğŸ­ Mock: Resuming node {node_name}")
            success = True
        else:
            # ì‹¤ì œ Slurm ëª…ë ¹ì–´ ì‹¤í–‰
            success, stdout, stderr = run_slurm_command(
                ['scontrol', 'update', f'NodeName={node_name}', 'State=RESUME']
            )
            
            if not success:
                return jsonify({
                    'success': False,
                    'error': 'Failed to resume node',
                    'details': stderr
                }), 500
        
        # ì´ë ¥ ê¸°ë¡
        history_entry = {
            'timestamp': datetime.now().isoformat(),
            'action': 'resume',
            'node_name': node_name,
            'success': True
        }
        node_history.append(history_entry)
        
        return jsonify({
            'success': True,
            'message': f'Node {node_name} resumed successfully',
            'node_name': node_name,
            'mode': 'mock' if MOCK_MODE else 'production',
            'timestamp': datetime.now().isoformat()
        })
        
    except Exception as e:
        logger.error(f"Error resuming node: {str(e)}")
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500


@node_bp.route('/nodes/reboot', methods=['POST'])
def reboot_node():
    """
    ë…¸ë“œë¥¼ ì¬ë¶€íŒ…
    POST /api/nodes/reboot
    Body: { "node_name": "cn01", "reason": "system update" }
    """
    try:
        # ë””ë²„ê¹…: Request ë°ì´í„° í™•ì¸
        logger.info(f"Reboot request received")
        logger.info(f"Content-Type: {request.content_type}")
        logger.info(f"Request data: {request.data}")
        
        data = request.get_json()
        logger.info(f"Parsed JSON: {data}")
        
        if data is None:
            logger.error("Failed to parse JSON from request")
            return jsonify({
                'success': False,
                'error': 'Invalid JSON or Content-Type. Expected application/json'
            }), 400
        
        node_name = data.get('node_name')
        reason = data.get('reason', 'Manual reboot')
        
        logger.info(f"Node name: {node_name}, Reason: {reason}")
        
        if not node_name:
            return jsonify({
                'success': False,
                'error': 'node_name is required'
            }), 400
        
        logger.info(f"MOCK_MODE status: {MOCK_MODE}")
        
        if MOCK_MODE:
            # Mock ëª¨ë“œì—ì„œëŠ” ì„±ê³µìœ¼ë¡œ ê°„ì£¼
            logger.info(f"ğŸ­ Mock: Rebooting node {node_name}")
            success = True
        else:
            # ì‹¤ì œ Slurm ëª…ë ¹ì–´ ì‹¤í–‰
            logger.info(f"Production mode: Rebooting node {node_name}")
            
            # Step 1: ë…¸ë“œë¥¼ DRAIN ìƒíƒœë¡œ ì„¤ì •
            logger.info(f"Step 1: Draining node {node_name}")
            try:
                drain_success, drain_stdout, drain_stderr = run_slurm_command(
                    ['scontrol', 'update', f'NodeName={node_name}', 'State=DRAIN', f'Reason={reason}']
                )
                logger.info(f"Drain result - Success: {drain_success}, Stderr: {drain_stderr}")
                
                if not drain_success:
                    logger.error(f"Failed to drain node: {drain_stderr}")
                    return jsonify({
                        'success': False,
                        'error': 'Failed to drain node before reboot',
                        'details': drain_stderr
                    }), 500
                
            except Exception as drain_error:
                logger.error(f"Drain command failed: {drain_error}")
                import traceback
                logger.error(traceback.format_exc())
                return jsonify({
                    'success': False,
                    'error': f'Drain command error: {str(drain_error)}'
                }), 500
            
            # Step 2: SSHë¡œ ì¬ë¶€íŒ… ëª…ë ¹ ì‹¤í–‰ (ì„ íƒì )
            # ì£¼ì˜: SSH í‚¤ ê¸°ë°˜ ì¸ì¦ì´ ì„¤ì •ë˜ì–´ ìˆì–´ì•¼ í•¨
            logger.info(f"Step 2: Sending reboot command via SSH to {node_name}")
            try:
                import subprocess
                # SSHë¥¼ í†µí•œ ì¬ë¶€íŒ… (ë°±ê·¸ë¼ìš´ë“œë¡œ ì‹¤í–‰)
                ssh_result = subprocess.run(
                    ['ssh', '-o', 'StrictHostKeyChecking=no', 
                     '-o', 'ConnectTimeout=5',
                     node_name, 
                     'sudo /sbin/reboot &'],
                    capture_output=True,
                    text=True,
                    timeout=10
                )
                
                logger.info(f"SSH reboot result - ReturnCode: {ssh_result.returncode}")
                
                # SSH ëª…ë ¹ì´ ì‹¤íŒ¨í•´ë„ DRAINì€ ì„±ê³µí–ˆìœ¼ë¯€ë¡œ ê³„ì† ì§„í–‰
                if ssh_result.returncode != 0:
                    logger.warning(f"SSH reboot command failed (node might not have SSH access): {ssh_result.stderr}")
                    # í•˜ì§€ë§Œ ì—ëŸ¬ë¥¼ ë°˜í™˜í•˜ì§€ ì•Šê³  ê²½ê³ ë§Œ ê¸°ë¡
                
                success = True  # DRAIN ì„±ê³µìœ¼ë¡œ ê°„ì£¼
                
            except subprocess.TimeoutExpired:
                logger.warning(f"SSH command timeout (node might be rebooting)")
                success = True  # Timeoutì€ ì¬ë¶€íŒ… ì‹œì‘ìœ¼ë¡œ ê°„ì£¼
            except Exception as ssh_error:
                logger.warning(f"SSH reboot failed: {ssh_error}")
                success = True  # SSH ì‹¤íŒ¨í•´ë„ DRAINì€ ì„±ê³µ
        
        # ì´ë ¥ ê¸°ë¡
        history_entry = {
            'timestamp': datetime.now().isoformat(),
            'action': 'reboot',
            'node_name': node_name,
            'reason': reason,
            'success': True
        }
        node_history.append(history_entry)
        
        return jsonify({
            'success': True,
            'message': f'Node {node_name} rebooting',
            'node_name': node_name,
            'reason': reason,
            'mode': 'mock' if MOCK_MODE else 'production',
            'timestamp': datetime.now().isoformat()
        })
        
    except Exception as e:
        logger.error(f"Error rebooting node: {str(e)}")
        import traceback
        logger.error(traceback.format_exc())
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500


@node_bp.route('/nodes/history', methods=['GET'])
def get_node_history():
    """
    ë…¸ë“œ ì‘ì—… ì´ë ¥ ì¡°íšŒ
    GET /api/nodes/history?node_name=cn01&limit=100
    """
    try:
        node_name = request.args.get('node_name')
        limit = int(request.args.get('limit', 100))
        
        # í•„í„°ë§
        filtered_history = node_history
        if node_name:
            filtered_history = [h for h in node_history if h.get('node_name') == node_name]
        
        # ìµœì‹ ìˆœ ì •ë ¬ ë° ì œí•œ
        filtered_history = sorted(filtered_history, key=lambda x: x['timestamp'], reverse=True)[:limit]
        
        return jsonify({
            'success': True,
            'history': filtered_history,
            'count': len(filtered_history),
            'mode': 'mock' if MOCK_MODE else 'production',
            'timestamp': datetime.now().isoformat()
        })
        
    except Exception as e:
        logger.error(f"Error fetching node history: {str(e)}")
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500


def init_app(app):
    """
    Flask ì•±ì— Blueprint ë“±ë¡
    """
    app.register_blueprint(node_bp, url_prefix='/api')
    logger.info("âœ… Node Management API registered")
