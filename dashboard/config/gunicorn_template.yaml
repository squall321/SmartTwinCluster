# Gunicorn Configuration Template
# 각 서비스별로 복사해서 사용

# ==================== Worker 설정 ====================
# 권장: (2 * CPU cores) + 1
# 리소스 제한을 위해 조정 가능
workers: 4

# Worker당 스레드 수 (gthread worker_class 사용 시)
threads: 2

# Worker 클래스
# - sync: 기본, 간단한 요청에 적합
# - gthread: 스레드 기반, I/O bound 작업에 적합
# - gevent: 비동기, 많은 동시 연결 처리
worker_class: "gthread"

# ==================== 리소스 제한 ====================
# 워커당 최대 요청 수 (메모리 누수 방지)
max_requests: 1000
max_requests_jitter: 50  # 랜덤 jitter로 동시 재시작 방지

# 타임아웃 (초)
timeout: 120
graceful_timeout: 30
keepalive: 5

# ==================== 네트워크 설정 ====================
bind: "127.0.0.1:5000"  # 각 서비스별로 포트 변경 필요
backlog: 2048

# ==================== 로깅 ====================
accesslog: "logs/gunicorn_access.log"
errorlog: "logs/gunicorn_error.log"
loglevel: "info"  # debug, info, warning, error, critical
access_log_format: '%({X-Forwarded-For}i)s %(l)s %(u)s %(t)s "%(r)s" %(s)s %(b)s "%(f)s" "%(a)s" %(D)s'

# ==================== 프로세스 관리 ====================
# PID 파일
pidfile: "logs/gunicorn.pid"

# Daemon 모드 (background 실행)
daemon: false  # systemd 사용 시 false, 수동 실행 시 true

# User/Group (권한 낮추기, root로 실행 시)
# user: "www-data"
# group: "www-data"

# ==================== 성능 최적화 ====================
# Worker 재활용 (메모리 관리)
worker_tmp_dir: "/dev/shm"  # RAM disk 사용 (Linux)

# Preload app (메모리 절약, 코드 변경 시 재시작 필요)
preload_app: true

# ==================== 보안 ====================
# 요청 크기 제한
limit_request_line: 4096
limit_request_fields: 100
limit_request_field_size: 8190

# ==================== 개발/프로덕션 전환 ====================
# Development
# - workers: 2
# - reload: true
# - loglevel: debug

# Production
# - workers: 4-8
# - reload: false
# - loglevel: warning
# - preload_app: true

reload: false  # 코드 변경 시 자동 재시작 (개발 모드에서만)

# ==================== CPU/Memory 제한 ====================
# 주의: Gunicorn 자체는 cgroups를 지원하지 않음
# systemd 또는 cgexec로 외부에서 제한 필요

# CPU 제한 예시 (systemd):
# CPUQuota=50%  # 50% CPU 사용 제한

# Memory 제한 예시 (systemd):
# MemoryLimit=2G  # 2GB 메모리 제한

# 워커 수로 간접 제한:
# workers = min(desired_workers, cpu_limit / worker_cpu_usage)
