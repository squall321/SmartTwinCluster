import { UploadedFile } from './types';

/**
 * 스크립트에서 auto-generated 섹션 제거
 */
export const removeAutoGeneratedSection = (script: string): string => {
  const lines = script.split('\n');
  let inAutoSection = false;
  let autoSectionEnd = -1;

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i].trim();
    
    // Auto-generated 섹션 시작
    if (line.includes('# Auto-generated file paths')) {
      inAutoSection = true;
      continue;
    }
    
    // Auto-generated 섹션 끝
    if (inAutoSection && line.includes('# --------')) {
      autoSectionEnd = i;
      break;
    }
  }

  // Auto-generated 섹션이 있으면 제거
  if (autoSectionEnd !== -1) {
    // shebang 찾기
    let shebangLine = '';
    let startIndex = 0;
    
    if (lines[0].startsWith('#!')) {
      shebangLine = lines[0];
      startIndex = 1;
    }

    // shebang 다음부터 auto-generated 섹션 전까지 찾기
    const beforeAuto = [];
    for (let i = startIndex; i < lines.length; i++) {
      const line = lines[i].trim();
      if (line.includes('# Auto-generated file paths')) {
        break;
      }
      beforeAuto.push(lines[i]);
    }

    // auto-generated 섹션 이후 라인들
    const afterAuto = lines.slice(autoSectionEnd + 1);

    // 재조합
    const result = [
      shebangLine,
      ...beforeAuto,
      ...afterAuto
    ].filter(line => line !== ''); // 빈 라인 제거는 하지 않음

    // 시작 부분의 빈 줄 정리
    while (result.length > 1 && result[1].trim() === '') {
      result.splice(1, 1);
    }

    return result.join('\n');
  }

  return script;
};

/**
 * 파일 목록으로 스크립트 업데이트
 */
export const updateScriptWithFiles = (
  currentScript: string,
  files: UploadedFile[],
  jobId: string
): string => {
  // 업로드된 파일이 없으면 기존 auto-generated 섹션만 제거
  if (files.length === 0) {
    return removeAutoGeneratedSection(currentScript);
  }

  // 기존 auto-generated 섹션 제거
  const cleanedScript = removeAutoGeneratedSection(currentScript);

  // 새로운 파일 변수 생성
  const fileVars = files
    .filter(f => f.status === 'uploaded') // 업로드 완료된 파일만
    .map(f => `${f.variableName}="${f.path}"`)
    .join('\n');

  // shebang 확인
  const lines = cleanedScript.split('\n');
  let shebang = '';
  let scriptBody = cleanedScript;

  if (lines[0] && lines[0].startsWith('#!')) {
    shebang = lines[0];
    scriptBody = lines.slice(1).join('\n');
  }

  // 스크립트 재조합
  const header = [
    shebang,
    '',
    '# Auto-generated file paths',
    fileVars,
    '# ---------------------------------',
    ''
  ].filter(line => line !== '' || shebang !== '').join('\n');

  return header + '\n' + scriptBody.trim();
};

/**
 * 스크립트에서 파일 변수 추출 (디버깅/검증용)
 */
export const extractFileVariables = (script: string): string[] => {
  const lines = script.split('\n');
  const variables: string[] = [];
  let inAutoSection = false;

  for (const line of lines) {
    const trimmed = line.trim();

    if (trimmed.includes('# Auto-generated file paths')) {
      inAutoSection = true;
      continue;
    }

    if (trimmed.includes('# --------')) {
      break;
    }

    if (inAutoSection && trimmed.includes('=')) {
      const match = trimmed.match(/^([A-Z_]+)=/);
      if (match) {
        variables.push(match[1]);
      }
    }
  }

  return variables;
};

/**
 * 스크립트 템플릿 생성
 */
export const createDefaultScript = (): string => {
  return `#!/bin/bash
#SBATCH --job-name=my_job

# Your script here
echo "Job started at $(date)"
hostname

# Example: Use uploaded files
# python train.py --data $DATA_CSV --model $MODEL_PT

echo "Job completed at $(date)"`;
};

/**
 * 파일 변수명 생성 (FileUploadSection과 동일한 로직)
 */
export const generateVariableName = (filename: string): string => {
  return filename
    .replace(/\.[^.]+$/, '') // 확장자 제거
    .replace(/[^a-zA-Z0-9]/g, '_') // 특수문자 → _
    .toUpperCase();
};

/**
 * LS-DYNA Single Job: K 파일 자동 설정
 */
export const updateLSDYNASingleJobScript = (
  currentScript: string,
  kFile: UploadedFile
): string => {
  // K 파일 변수 삽입 위치 찾기
  const lines = currentScript.split('\n');
  let insertIndex = -1;
  
  // "# K file will be automatically set here" 다음 줄에 삽입
  for (let i = 0; i < lines.length; i++) {
    if (lines[i].includes('# K file will be automatically set here')) {
      insertIndex = i + 1;
      break;
    }
  }
  
  if (insertIndex === -1) {
    // 삽입 위치를 못 찾으면 NPROCS 다음에 삽입
    for (let i = 0; i < lines.length; i++) {
      if (lines[i].includes('NPROCS=')) {
        insertIndex = i + 2;
        break;
      }
    }
  }
  
  if (insertIndex === -1) {
    console.warn('Could not find insertion point for K file');
    return currentScript;
  }
  
  // 기존 K_FILE 라인 제거
  const filteredLines = lines.filter(line => !line.trim().startsWith('K_FILE='));
  
  // 새로운 K_FILE 라인 삽입
  const kFileLine = `K_FILE="${kFile.path}"`;
  filteredLines.splice(insertIndex, 0, kFileLine);
  
  return filteredLines.join('\n');
};

/**
 * LS-DYNA Array Job: 여러 K 파일 배열 설정
 */
export const updateLSDYNAArrayJobScript = (
  currentScript: string,
  kFiles: UploadedFile[]
): string => {
  // K 파일 필터링 (.k 확장자만)
  const validKFiles = kFiles.filter(f => 
    f.name.toLowerCase().endsWith('.k') && f.status === 'uploaded'
  );
  
  if (validKFiles.length === 0) {
    return currentScript;
  }
  
  const lines = currentScript.split('\n');
  let insertIndex = -1;
  
  // "# K_FILES array will contain" 다음에 삽입
  for (let i = 0; i < lines.length; i++) {
    if (lines[i].includes('# K_FILES array will contain')) {
      // Example 주석 블록 건너뛰기
      for (let j = i + 1; j < lines.length; j++) {
        if (lines[j].trim() === '# )' || lines[j].trim() === '#)') {
          insertIndex = j + 1;
          break;
        }
      }
      break;
    }
  }
  
  if (insertIndex === -1) {
    console.warn('Could not find insertion point for K files array');
    return currentScript;
  }
  
  // 기존 K_FILES 배열 제거
  const filteredLines: string[] = [];
  let inKFilesArray = false;
  
  for (const line of lines) {
    if (line.trim().startsWith('K_FILES=(')) {
      inKFilesArray = true;
      continue;
    }
    if (inKFilesArray && line.trim() === ')') {
      inKFilesArray = false;
      continue;
    }
    if (!inKFilesArray) {
      filteredLines.push(line);
    }
  }
  
  // 새로운 K_FILES 배열 생성
  const kFilesArray = [
    'K_FILES=(',
    ...validKFiles.map(f => `  "${f.path}"`),
    ')'
  ];
  
  // 삽입
  filteredLines.splice(insertIndex, 0, ...kFilesArray);
  
  return filteredLines.join('\n');
};

/**
 * 스마트 스크립트 업데이트: 템플릿에 따라 자동 선택
 */
export const updateScriptWithFilesSmartly = (
  currentScript: string,
  files: UploadedFile[],
  jobId: string,
  templateId?: string
): string => {
  // LS-DYNA Single Job 템플릿
  if (templateId === 'template-lsdyna-single') {
    const kFiles = files.filter(f => 
      f.name.toLowerCase().endsWith('.k') && f.status === 'uploaded'
    );
    
    if (kFiles.length > 0) {
      // 첫 번째 K 파일만 사용
      return updateLSDYNASingleJobScript(currentScript, kFiles[0]);
    }
    return currentScript;
  }
  
  // LS-DYNA Array Job 템플릿
  if (templateId === 'template-lsdyna-array') {
    return updateLSDYNAArrayJobScript(currentScript, files);
  }
  
  // 기본 동작: 일반 파일 업로드
  return updateScriptWithFiles(currentScript, files, jobId);
};
